There were a lot of design decisions that went into our project. One of the most important was whether or not to put the todo list on the right or left side of the page. Besides this crucial decision that tore our group apart, there were also specific coding decisions that were made throughout the project. From the beginning, we decided to go with the Django framework for a couple reasons. Even though nobody had any experience with Python or Django before this project, we thought that the benefits of the structure given by such a framework certainly outweighed the costs of spending some extra time learning how to use it. We had also heard good things and wanted to learn the "best" web-programming language. The project had two main components: calendar and todo list. For the calendar, we used a jQuery plugin called fullcalendar (http://arshaw.com/fullcalendar/). This plugin allowed us to easily add properly formatted events to the calendar, and handled dragging and resizing. One of the major fallbacks of this plugin was the lack of support for repeating events. While writing the code to handle repeating events and different repeat rules and end repeat dates, we realized how annoying it is to write code for repeating events. There are a lot of specific corner cases that must be handled the right way (we even implemented a lot of corner cases that iCal didn't even handle properly!). In order to store the information about events and repeating events in the database, we created classes for Event, RepeatEvent, and BreakEvent objects. Each RepeatEvent object not only stored all the information necessary for an event (start, end, id, allDay, endRepeat) but also had a set of BreakEvent objects in order to deal with breaks in a repeating chain. This database structure allowed for easy construction of the calendar, and also easy editing based on changes on the client side. In the database, there were also classes for the todo list Tasks as well as something called a Note. Notes were used for communication between users when events were shared from one user to another. In order to have separate events for each user, a django ForeignKey was used for each Event, RepeatEvent, and Task class so that each user had a set of events and repeat events.
 
Because the idea of our project was to have a todo list and planner on the same page, we wrote also all of our code in javascript files. For stylizing and for additional functionality, we linked in to jQuery and jQueryUI libraries. We broke up the javascript files into different components. Login.js dealt with user authentication and notifying the user of typing in an invalid username and password etc. Then each major function of our website had a javascript file to deal with user interaction without loading a new url. Ajax requests were used all over the place to ensure that there was a constant link with the server without refreshing the page. Whenever the user adds, edits, or deletes an event or todo list item, a POST request is sent to the server to record the changes so that when the user returns to the webpage all the events and todo items are the same as when he or she left. The largest of these javascript files by far was cal.js, which held all the code to ensure that all the user interactions with the calendar were handled properly and all the changes were properly sent to the database.
 
In terms of how we wrote our code, we tried to abstract a lot of the common functionality out into different functions. This proved to be essential when dealing with all the possible interactions with the calendar when implementing repeating events. This was a feature that was completely overlooked at first but actually proved to be the hardest one to implement. We broke up possible interactions with the calendar into 8 different functions that could cover these actions. In addition to these 8 functions, there were various corner cases to consider. Just one to consider, for example, is when you edit the second to beginning of a repeating event. In which case the head of the repeating event should be changed into a stand alone event because it no longer has any future linked events. Then, this had to be implemented with breaks and end repeat dates and the user changing the repeat rule. There always had to be constant communication with the server such that at any moment a refresh would be able to rebuild the events in exactly the same way they were.
 
All in all, we ended up writing a LOT of code; cal.js is something like 1472 lines of code. Note that we are not responsible for all of the code in our project. fullcalendar.js and full calendar.css come from the query plugin, as did the basic (maybe a few hundred lines) version of cal.js, and jquery,keyfilter,js we found online, as well as part of cal.js used to set up autocomplete (from query ui). But the rest was all us, though we spent a lot of time researching methods and especially syntax online.
